import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;

class AFInventoryService {

	@PersistenceContext("main")
	def em;
	
	
	
	
	/****
	* before posting deboit ensure no conflicts in the inventory
	**/
	@ProxyMethod
	public void postDebit(def receipt) { 
		def conflicts = [];
		receipt.items.each {
			def m = [af:it.af, startseries:it.startseries, endseries:it.endseries, prefix:it.prefix, suffix:it.suffix];
			boolean b = checkConflictSeries(m);
			if(b) {
				conflicts << m.af;
			}
			else {
				def afinvtry = [:];
				afinvtry.putAll( it );
				afinvtry.objid = it.controlid;
				afinvtry.currentseries = afinvtry.startseries;
				afinvtry.currentstub = afinvtry.startstub;
				afinvtry.receiptid = receipt.objid;
				afinvtry.reqid = receipt.reqid;
				
				//qty here refers to the number of pieces
				afinvtry.qtyreceived = it.qty;
				afinvtry.qtyissued = 0;
				afinvtry.state = "OPEN";
				afinvtry.txndate = receipt.txndate;
				em.create("afinventorycontrol", afinvtry);
			}	
		}	
		if(conflicts)
			throw new Exception("Conflict on the ff. series " + conflicts.join(","));
	}

	@ProxyMethod
	public boolean checkConflictSeries( def c) {
		def builder = new StringBuilder();
		if( c.prefix ) {
			builder.append( ''' AND prefix=$P{prefix} ''' ); 
		}
		else {
			builder.append( " AND prefix IS NULL ");
		}
		if( c.suffix ) {
			builder.append( ''' AND suffix=$P{suffix} ''' ); 
		}
		else {
			builder.append( " AND suffix IS NULL ");
		}
		def qry = em.sqlContext.createNamedQuery("afinventory:checkConflictSeries");
		def test = qry.setVars([filter:builder.toString()]).setParameters(c).singleResult;
		if(test) 
			return true;
		else
			return false;
	}
	
	
	/**
	* locate the inventory control id and update the currentstub, currentseries, and qtyissued
	* when posting make sure that it is still the same start series.  
	* Otherwise, issuer must execute getAvailableAF again. This is to prevent concurrency issues
	*/
	@ProxyMethod
	public void postCredit( def receipt )  {
		def conflicts = [];
		def exc = em.sqlContext.createNamedExecutor("afinventory:updateInventory");	
		def checker = em.sqlContext.createNamedQuery("afinventory:checkSeriesPriorUpdate");	
		
		receipt.items.each {
			def z = checker.setParameter("controlid", it.controlid ).singleResult;
			if(!z) {
				throw new Exception("Inventory control for "+it.af + " does not exist");
			}
			else if(z.currentseries!=it.startseries) {
				conflicts << it.af 
			}
			else {
				def m = [nextseries: it.endseries+1 ,nextstub:it.endstub+1];
				m.controlid = it.controlid;
				m.qty = it.qty;
				exc.setParameters(m).execute();
			}	
		}
		if(conflicts)
			throw new Exception("Series was already updated for the following : " + conflicts.join(","));
	}
	
	@ProxyMethod
	public def getAvailableAF( def p ) {
		def result = [items:[]];
		int qty = p.qty;
		def list = em.sqlContext.createNamedQuery("afinventory:getAvailableAF")
			.setParameters(p).resultList;
		for(o in list) {
			if(qty<=0) break;
			
			if(qty > o.qtybalance) {
				qty -= o.qtybalance;
				o.qty = o.qtybalance;
			}
			else {
				o.qty = qty;
				qty = 0;
			}
			o.remove("qtybalance");
			o.endseries = o.startseries + (o.unitqty * o.qty)-1;
			o.endstub = o.startstub + o.qty - 1;
			result.items << o;
		}
		if(qty>0)
			throw new Exception("Not enough accountable forms in stock");
		
		return result;
	}
	
	
	
	
}
