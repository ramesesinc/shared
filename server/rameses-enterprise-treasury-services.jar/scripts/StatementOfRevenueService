import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.common.*;
import com.rameses.services.extended.*;


class StatementOfRevenueService  
{

	@ActiveDB('statementofrevenue')
	def db 

	@PersistenceContext("main")
	def em; 

	@Service('RPTUtil')
	def util

	@Service('DateService')
	def dtSvc 

	def PADDING_SIZE = 10


	@ProxyMethod
	public def generateReport( params ) {
		util.required('Chart Type', params.charttype)	//charttype values: ngas, sre
		util.required('Year', params.year)
		util.required('Qtr', params.qtr)				//values : 1,2,3,4
		//
		// parameters month and day are optional
		//

		buildDateFilter(params)
		def items = getSummarizedRevenueItems(params)
		def reportdata = buildChartOfAccountFormat(params, items)
		if (params.hidezeroamount) {
			reportdata.removeAll(reportdata.findAll{it.amount <= 0.0 })
		}

		//generate group totals 
		/*
		reportdata.findAll{it.leaf == null}.each{
			it."total${it.level}" = it.amount
			it.amount = 0.0
		}
		*/
		
		return [
			title 		: 'STATEMENT OF REVENUE',
			period 		: util.buildPeriod(params),
			reportdata  : reportdata,
		]
	}


	def padTitle(title, idx){
		return (' ' * PADDING_SIZE * idx) + title
	}


	def buildChartOfAccountFormat(params, items){
		def data = []
		data += items.findAll{it.objid == 'unmapped'}.each{ it.leaf = 1}
		def idx = -1
		db.getRootAccounts().each{ 
			if (params.type.equalsIgnoreCase('standard')) {
				doBuildStandardFormat(data, items, idx, it)
			}
			else if (params.type.equalsIgnoreCase('extended')){
				doBuildExtendedFormat(data, items, idx, it)
			}
			else if (params.type.equalsIgnoreCase('detailed')){
				doBuildDetailedFormat(data, items, idx, it)
			}
		}
		if (!params.type.equalsIgnoreCase('detailed'))
			calculateGroupTotals(data)
		else  
			calculateDetailedGroupTotals(data)
		return data 
	}


	void calculateDetailedGroupTotals(data){
		def maxlevel = data.level.max() 
		for(int i = maxlevel; i > 0; i--){
			['subaccount','detail','group'].each{ type -> 
				def groupaccts = data.findAll{it.level == i && it.type == type && it.leaf == null}
				groupaccts.each{ grpacct ->
					def colls = data.findAll{it.parentid == grpacct.objid}
					def amt = colls.amount.sum()
					if (amt > 0.0 && grpacct.amount == 0){
						grpacct.amount = amt
					}
				}
			}
		}

		//update rootgroups
		data.findAll{it.level == 0 }.each{ rgrp ->
			def amt = data.findAll{it.parentid == rgrp.objid}.amount.sum();
			if (amt > 0.0){
				rgrp.amount = amt 
			}
		}
	}

	void calculateGroupTotals(data){
		def maxlevel = data.level.max() 
		for(int i = maxlevel - 1; i > 0; i--){
			['detail','group'].each{ type -> 
				def groupaccts = data.findAll{it.level == i && it.type == type }
				groupaccts.each{ grpacct ->
					def colls = data.findAll{it.parentid == grpacct.objid}
					def amt = colls.amount.sum()
					if (amt > 0.0 && grpacct.amount == 0){
						grpacct.amount = amt
					}
					else if (amt > 0.0 && grpacct.amount != 0){
						def idx = data.indexOf(grpacct) + colls.size() + 1
						def otheracct = [objid:'O'+ grpacct.objid, parentid:grpacct.objid, title:(' '*PADDING_SIZE) + grpacct.title + ' (OTHERS)', amount:grpacct.amount, leaf:1, type:'subaccount', level:grpacct.level+1]
						data.add(idx, otheracct)
						grpacct.amount += amt
						grpacct.leaf = null
					}
				}
			}
		}

		//update rootgroups
		data.findAll{it.level == 0 }.each{ rgrp ->
			def amt = data.findAll{it.parentid == rgrp.objid}.amount.sum();
			if (amt > 0.0){
				rgrp.amount = amt 
			}
		}

	}

	void doBuildStandardFormat(data, items, idx, acct){
		idx += 1
		acct.title = padTitle(acct.title, idx)
		acct.amount = 0.0
		acct.level = idx 
		def collections = items.findAll{it.accountid == acct.objid}
		if (collections){
			acct.amount = collections.amount.sum()
			acct.leaf = 1
		}
		data << acct
		db.getStandardSubAccounts([parentid:acct.objid]).each{
			doBuildStandardFormat(data, items, idx, it )
		}
	}


	void doBuildExtendedFormat(data, items, idx, acct){
		idx += 1
		acct.title = padTitle(acct.title, idx)
		acct.amount = 0.0
		acct.level = idx 
		def collections = items.findAll{it.accountid == acct.objid}
		if (collections){
			acct.amount = collections.amount.sum()
			acct.leaf = 1
		}
		data << acct
		db.getExtendedSubAccounts([parentid:acct.objid]).each{
			doBuildExtendedFormat(data, items, idx, it )
		}
	}


	void doBuildDetailedFormat(data, items, idx, acct){
		idx += 1
		acct.title = padTitle(acct.title, idx)
		acct.amount = 0.0
		acct.level = idx 
		data << acct

		def collections = items.findAll{it.parentid == acct.objid}.each{
			it.title = padTitle(it.title, idx+1)
			it.leaf = 1
		}
		if (collections){
			acct.amount = collections.amount.sum()
			acct.leaf = null
			data.addAll(collections)
		}
		
		db.getExtendedSubAccounts([parentid:acct.objid]).each{
			doBuildDetailedFormat(data, items, idx, it )
		}
	}


	def getSummarizedRevenueItems(params){
		if (params.charttype.equalsIgnoreCase('ngas')){
			if (params.type.equalsIgnoreCase('standard')) {
				return db.getNgasStandardRevenueItemSummaries(params)
			}
			else if (params.type.equalsIgnoreCase('extended')) {
				return db.getNgasExtendedRevenueItemSummaries(params)
			}
			else if (params.type.equalsIgnoreCase('detailed')) {
				return db.getNgasDetailedRevenueItemSummaries(params)
			}
			else {
				throw new Exception('Report type ' + params.type + ' is not supported.')
			}
		}
	}


	void buildDateFilter(params){
		if (params.qtr != null && params.month != null) {
			params.fromdate = params.year + '-' + params.month.index + '-01'
			params.todate   = dtSvc.add( dtSvc.getMonthEndDate(dtSvc.parse('yyyy-MM-dd', params.fromdate)), '1d')
		}
		else {
			params.fromdate = dtSvc.getBeginningQtrDate( params.qtr, params.year, 1 )
			params.todate   = dtSvc.add( dtSvc.getQtrEndDate( params.qtr, params.year ), '1d')
		}
	}

}
